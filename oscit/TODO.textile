h1. Rubyk: TODO

√  Compile with Location code
√  Replace occurences of IpEndPointName by Location
√  Sign incoming messages: from location + target Url
Root::call() ---> Object::safe_trigger() ---> Object::trigger()
√ Write the tests for ProxyFactory
√ Use signature to route in '/.reply' handler
√ Start Proxy code...
√ File class
√ /.view method & spec
10. refactor: Couldn't we can remove "const Location *origin" from trigger ?
              If we really need a remote location, it will probably be different from the UDP/OSC caller
              and it's the caller's job to give us an Url (as string): "IP:port/video1" for example.
10. refactor: const correctness (do not return const values: const reference or value)
11. refactor: script.h should use File

h2. Proxy stuff

ProxyFactory

h2. TODO: later

0. Fix IP resolution (ZeroConf code):
   Understand how we can connect to the remote when we have resolved from ZeroConfBrowser
   and adapt Location to store the relative information.
1. RefCount locations (shared objects ?).
2. Merge 'Location *origin' with 'Mutex *caller_context' ?
  Location can be
  a. Remote Location ===> need lock
  b. Local context   ===> need lock if context is different

3. Choose once and for all between "const char*" or std::string !!

h2. DOCUMENTATION

+--------------+-------------+
| inside oscit | command     |
|  <- url      |  <-  path   |
|              |    + loc    |
+-------------+--------------+

Comming in  = path
Inside ruby = url or path


